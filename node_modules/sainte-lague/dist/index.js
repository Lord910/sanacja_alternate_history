'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var roundWithPrecision = require('lodash/round');
var sortBy = require('lodash/sortBy');
var fromPairs = require('lodash/fromPairs');
var range = require('lodash/range');
var flatMap = require('lodash/flatMap');
var sampleSize = require('lodash/sampleSize');

// we round all numbers to the same precision to catch floating point rounding errors
// which is especially relevant if two parties should have exactly the same quotient for a seat
var precision = function precision(x) {
	return roundWithPrecision(x, 14);
};

var sum = function sum(partyValues) {
	return Object.values(partyValues).reduce(function (accumulator, currentValue) {
		return accumulator + currentValue;
	}, 0);
};

var distribute = function distribute(votes, seats) {
	var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	var options = Object.assign({ draw: false }, opt);

	if (Object.values(votes).length < 1) throw new Error('vote distribution must contain at least one party');
	if (!Object.values(votes).every(function (voteCount) {
		return typeof voteCount === 'number' && voteCount >= 0;
	})) throw new Error('party vote counts must be non-negative integers');
	if (!Number.isInteger(seats) || seats <= 0) throw new Error('seats must be a positive integer');
	if (typeof options.draw !== 'boolean') throw new Error('opt.draw must be a boolean');

	var totalVotes = sum(votes);

	// minimum seat count per party
	// smallest divisor: original seat count - number of parties
	var minimumSeatsPerParty = fromPairs(Object.entries(votes).map(function (_ref) {
		var _ref2 = _slicedToArray(_ref, 2),
		    party = _ref2[0],
		    voteCount = _ref2[1];

		var minimumTotalSeatsForDivisor = Math.max(seats - Object.keys(votes).length, 0);
		var seatCount = Math.round(minimumTotalSeatsForDivisor * voteCount / totalVotes);
		return [party, seatCount];
	}));

	// maximum seat count per party
	// largest divisor: original seat count + number of parties
	var maximumSeatsPerParty = fromPairs(Object.entries(votes).map(function (_ref3) {
		var _ref4 = _slicedToArray(_ref3, 2),
		    party = _ref4[0],
		    voteCount = _ref4[1];

		var maximumTotalSeatsForDivisor = seats + Object.keys(votes).length;
		var seatCount = Math.min(Math.round(maximumTotalSeatsForDivisor * voteCount / totalVotes), seats);
		return [party, seatCount];
	}));

	var undeterminedQuotients = flatMap(Object.entries(votes).map(function (_ref5) {
		var _ref6 = _slicedToArray(_ref5, 2),
		    party = _ref6[0],
		    voteCount = _ref6[1];

		var minimumSeats = minimumSeatsPerParty[party];
		var maximumSeats = maximumSeatsPerParty[party];
		return range(minimumSeats, maximumSeats).map(function (seatNumber) {
			var quotient = precision(voteCount / (seatNumber + 0.5));
			return { party: party, quotient: quotient };
		});
	}));

	var seatsAllocatedSoFar = sum(minimumSeatsPerParty);
	var seatsLeft = seats - seatsAllocatedSoFar;
	var sortedUndeterminedQuotients = sortBy(undeterminedQuotients, function (_ref7) {
		var quotient = _ref7.quotient;
		return -quotient;
	});

	var smallestWinningQuotient = sortedUndeterminedQuotients[seatsLeft - 1].quotient;
	var guaranteedWinners = sortedUndeterminedQuotients.filter(function (_ref8) {
		var quotient = _ref8.quotient;
		return quotient > smallestWinningQuotient;
	});
	var nonGuaranteedWinners = sortedUndeterminedQuotients.filter(function (_ref9) {
		var quotient = _ref9.quotient;
		return quotient === smallestWinningQuotient;
	});

	if (guaranteedWinners.length + nonGuaranteedWinners.length === seatsLeft) guaranteedWinners.push.apply(guaranteedWinners, _toConsumableArray(nonGuaranteedWinners));else {
		if (!options.draw) throw new Error('result is ambiguous, a draw would need to be made, but opt.draw is disabled');
		// draw the  missing seats from non-guaranteed winners
		guaranteedWinners.push.apply(guaranteedWinners, _toConsumableArray(sampleSize(nonGuaranteedWinners, seatsLeft - guaranteedWinners.length)));
	}

	return guaranteedWinners.reduce(
	// accumulator function
	function (accumulator, _ref10) {
		var party = _ref10.party;

		accumulator[party] += 1;
		return accumulator;
	},
	// starting value: minumum seats per party
	minimumSeatsPerParty);
};

module.exports = distribute;